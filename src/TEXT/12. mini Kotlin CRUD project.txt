코틀린의 제네릭과 타입 파라미터는 스프링 프레임워크(Spring Framework) 기반의 애플리케이션에서 매우 유용하게 사용됩니다.
스프링에서는 제네릭을 활용하여 다양한 컴포넌트와 서비스에서 타입 안전성을 보장하고, 코드의 재사용성을 높입니다.



###  제네릭 JPA 리포지토리
스프링 데이터 JPA(Spring Data JPA)와 같은 라이브러리에서는 제네릭을 사용하여 데이터 접근 계층을 간결하고 타입 안전하게 관리할 수 있습니다.
스프링 데이터 JPA에서는 제네릭 리포지토리를 사용하여 엔티티 타입과 그 타입의 ID를 제네릭 파라미터로 지정합니다.

    @Entity
    data class Team(
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        val id: Long? = null,
        val name: String,

        @OneToMany(mappedBy = "team")
        val users: Set<User> = emptySet()
    )


    @Entity
    data class User(
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        val id: Long? = null,
        val name: String,
        val email: String,

        @ManyToOne
        val team: Team? = null,

        @Enumerated(EnumType.STRING)
        val role: Role
    )


    enum class Role {
        ADMIN,
        USER,
        GUEST
    }


    @Repository
    interface TeamRepository : JpaRepository<Team, Long> {
        fun findByName(name: String): List<Team>
    }


    @Repository
    interface UserRepository : JpaRepository<User, Long> {
        fun findByName(name: String): List<User>
        fun findByTeamId(teamId: Long): List<User>
    }


    @Service
    class UserService @Autowired constructor(
        private val userRepository: UserRepository,
        private val teamRepository: TeamRepository
    ) {

        fun getAllUsers(): List<User> {
            return userRepository.findAll()
        }

        fun getUserById(id: Long): Optional<User> {
            return userRepository.findById(id)
        }

        fun createUser(user: User): User {
            return userRepository.save(user)
        }

        fun updateUser(id: Long, updatedUser: User): Optional<User> {
            return if (userRepository.existsById(id)) {
                val userToUpdate = updatedUser.copy(id = id)
                Optional.of(userRepository.save(userToUpdate))
            } else {
                Optional.empty()
            }
        }

        fun deleteUser(id: Long): Boolean {
            return if (userRepository.existsById(id)) {
                userRepository.deleteById(id)
                true
            } else {
                false
            }
        }

        fun findUsersByName(name: String): List<User> {
            return userRepository.findByName(name)
        }

        fun findUsersByTeamId(teamId: Long): List<User> {
            return userRepository.findByTeamId(teamId)
        }

        fun addUserToTeam(userId: Long, teamId: Long): Optional<User> {
            val user = userRepository.findById(userId)
            val team = teamRepository.findById(teamId)
            if (user.isPresent && team.isPresent) {
                val updatedUser = user.get().copy(team = team.get())
                return Optional.of(userRepository.save(updatedUser))
            }
            return Optional.empty()
        }

        fun removeUserFromTeam(userId: Long): Optional<User> {
            val user = userRepository.findById(userId)
            if (user.isPresent) {
                val updatedUser = user.get().copy(team = null)
                return Optional.of(userRepository.save(updatedUser))
            }
            return Optional.empty()
        }
    }


    @RestController
    @RequestMapping("/users")
    class UserController @Autowired constructor(private val userService: UserService) {

        @GetMapping
        fun getAllUsers(): List<User> {
            return userService.getAllUsers()
        }

        @GetMapping("/{id}")
        fun getUserById(@PathVariable id: Long): ResponseEntity<User> {
            return userService.getUserById(id)
                .map { user -> ResponseEntity.ok(user) }
                .orElse(ResponseEntity.notFound().build())
        }

        @PostMapping
        fun createUser(@RequestBody user: User): ResponseEntity<User> {
            return ResponseEntity.ok(userService.createUser(user))
        }

        @PutMapping("/{id}")
        fun updateUser(@PathVariable id: Long, @RequestBody updatedUser: User): ResponseEntity<User> {
            return userService.updateUser(id, updatedUser)
                .map { user -> ResponseEntity.ok(user) }
                .orElse(ResponseEntity.notFound().build())
        }

        @DeleteMapping("/{id}")
        fun deleteUser(@PathVariable id: Long): ResponseEntity<Void> {
            return if (userService.deleteUser(id)) {
                ResponseEntity.noContent().build()
            } else {
                ResponseEntity.notFound().build()
            }
        }

        @GetMapping("/search")
        fun findUsersByName(@RequestParam name: String): List<User> {
            return userService.findUsersByName(name)
        }

        @GetMapping("/team/{teamId}")
        fun findUsersByTeamId(@PathVariable teamId: Long): List<User> {
            return userService.findUsersByTeamId(teamId)
        }

        @PostMapping("/{userId}/team/{teamId}")
        fun addUserToTeam(@PathVariable userId: Long, @PathVariable teamId: Long): ResponseEntity<User> {
            return userService.addUserToTeam(userId, teamId)
                .map { user -> ResponseEntity.ok(user) }
                .orElse(ResponseEntity.notFound().build())
        }

        @DeleteMapping("/{userId}/team")
        fun removeUserFromTeam(@PathVariable userId: Long): ResponseEntity<User> {
            return userService.removeUserFromTeam(userId)
                .map { user -> ResponseEntity.ok(user) }
                .orElse(ResponseEntity.notFound().build())
        }
    }
















